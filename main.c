/**
  ******************************************************************************
  * @file    main.c
  * @author  Auto-generated by STM32CubeIDE
  * @version V1.0
  * @brief   Default main function.
  ******************************************************************************
*/

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#include <stdio.h>
#include <stdint.h>
#include "main.h"
#include "led.h"

void task1_handler(void);
void task2_handler(void);
void task3_handler(void);
void task4_handler(void);
void schedule_next_task(void);
void enable_processor_faults(void);
void init_tasks_stack(void);
void init_systick_timer(uint32_t tick_hz);
__attribute ((naked))void init_scheduler_stack(uint32_t sched_stack_top);
__attribute ((naked)) void switch_msp_to_psp(void);

extern void initialise_monitor_handles(void);

typedef struct{
	uint32_t psp_value;
	uint32_t block_count;
	uint8_t current_state;
	void(*task_handler)(void);
}TCB_t;

TCB_t user_tasks[MAX_TASKS];

uint32_t g_tick_count = 0;
uint8_t current_task = 1;


const uint32_t const_1 = 200;
int main(void)
{
	enable_processor_faults();

	initialise_monitor_handles();

	init_scheduler_stack(SCHED_STACK_START);

	init_tasks_stack();
	// printf("Heloo World\n");
	led_init_all();

	init_systick_timer(1000);

	switch_msp_to_psp();

	
	task1_handler();



	for(;;);
}

void task_delay(uint32_t tick_count){

	//disable interrupt becasue we are going to use a shared resource (user_tasks)

	INTERRUPT_DISABLE();
	if(current_task){
		user_tasks[current_task].block_count = g_tick_count + tick_count;
		user_tasks[current_task].current_state = TASK_BLOCKED_STATE;
	}
	schedule_next_task();

	//enable interrupts
	INTERRUPT_ENABLE();
}

void idle_task(void){
	while(1);
}

void task1_handler(void){

	
	while(1){
		printf("Task 1 is executing\n");
		led_on(LED_GREEN);
		task_delay(1000);
		led_off(LED_GREEN);
		task_delay(1000);
	}

}

void task2_handler(void){

	
	while(1){
		printf("Task 2 is executing\n");
		led_on(LED_ORANGE);
		task_delay(500);
		led_off(LED_ORANGE);
		task_delay(500);
	}

}

void task3_handler(void){

	
	while(1){
		printf("Task 3 is executing\n");
		led_on(LED_BLUE);
		task_delay(250);
		led_off(LED_BLUE);
		task_delay(250);
	}

}

void task4_handler(void){

	
	while(1){
		printf("Task 4 is executing\n");
		led_on(LED_RED);
		task_delay(125);
		led_off(LED_RED);
		task_delay(125);
	}

}

/*Get PSP of currently running Task*/
uint32_t get_psp_value(void){

	return user_tasks[current_task].psp_value;
}
__attribute ((naked)) void switch_msp_to_psp(void){

	//1. Initialize PSP with TASK1_STACK_START
	__asm volatile("PUSH {LR}");//need to do this to go back to main function after exiting this function.
								//The LR will get corrupted when get_psp_value is called in the next step. So we must preserve it
	__asm volatile("BL get_psp_value"); //after this executes, PSP value will be stored in R0
	__asm volatile("MSR PSP, R0");
	__asm volatile("POP {LR}");
	//2. Switch SP from MSP to PSP
	__asm ("MRS R0, CONTROL");
	__asm ("ORR R0, #2");
	__asm ("MSR CONTROL, R0");
	__asm volatile("BX LR");


}

void enable_processor_faults(void){

	volatile uint32_t *pSHCSR = (volatile uint32_t*)0xE000ED24;
	*pSHCSR |= (1 << 18); //enable Usage Fault
	*pSHCSR |= (1 << 17); //enable Bus Fault
	*pSHCSR |= (1 << 16); //enable MemManage Fault

}
void init_tasks_stack(){

	user_tasks[0].current_state = TASK_READY_STATE; //idle task must be blocked. it should run only when all the other tasks are blocked
	user_tasks[1].current_state = TASK_READY_STATE;
	user_tasks[2].current_state = TASK_READY_STATE;
	user_tasks[3].current_state = TASK_READY_STATE;
	user_tasks[4].current_state = TASK_READY_STATE;

	user_tasks[0].psp_value = IDLE_TASK_STACK_START;
	user_tasks[1].psp_value = T1_STACK_START;
	user_tasks[2].psp_value = T2_STACK_START;
	user_tasks[3].psp_value = T3_STACK_START;
	user_tasks[4].psp_value = T4_STACK_START;

	user_tasks[0].task_handler = idle_task;
	user_tasks[1].task_handler = task1_handler;
	user_tasks[2].task_handler = task2_handler;
	user_tasks[3].task_handler = task3_handler;
	user_tasks[4].task_handler = task4_handler;

	uint32_t *pPSP;
	for(uint32_t i = 0; i < MAX_TASKS; i++){
		pPSP = (uint32_t*)user_tasks[i].psp_value;

		pPSP--;
		*pPSP = DUMMY_XPSR;

		pPSP--;
		*pPSP = (uint32_t)user_tasks[i].task_handler; //this should hold the address of task handler (because this is where the task will resume)

		pPSP--;
		*pPSP = 0xFFFFFFFD; //referred ARm Cortex Generic User Guide to see all the possible values of LR

		for(int j = 0; j < 13; j++){
			pPSP--;
			*pPSP = 0; //R12
		}

		user_tasks[i].psp_value = (uint32_t)pPSP;

	}
}

void init_systick_timer(uint32_t tick_hz){
	uint32_t *pSCSR	= (uint32_t*)0xE000E010;
	uint32_t *pSRVR  = (uint32_t*)0xE000E014;
	uint32_t count_value = ((SYSTICK_TIM_CLK)/tick_hz) - 1;

	/*Load Systick Reload Value Register with Reload Value corresponding to 1ms interrupt*/
	*pSRVR &= ~(0xFFFFFF);
	*pSRVR |= count_value;

	/*Configure Systick Control and Status Register*/
	*pSCSR |= (1 << 2); //enable processor clock to systick peripheral
	*pSCSR |= (1 << 1); //enable systick interrupt
	*pSCSR |= (1 << 0); //enable systick peripheral
}

/*Initializes the MSP with the Top of Scheduler Stack*/
__attribute ((naked))void init_scheduler_stack(uint32_t sched_stack_top){

	__asm ("MSR MSP, R0");
	__asm ("BX LR");

}

void save_psp_value(uint32_t current_psp_value){
	user_tasks[current_task].psp_value = current_psp_value;
}

void update_next_task(){

	uint32_t state = TASK_BLOCKED_STATE;
	for(int i = 0; i < MAX_TASKS; i++){
		current_task++;
		current_task %= MAX_TASKS;

		state = user_tasks[current_task].current_state;
		if( (state == TASK_READY_STATE) && (current_task != 0)){
			break;
		}
	}

	if(state != TASK_READY_STATE){ //if all the user tasks are in blocked state, next task must be idle_task
		current_task = 0;
	}


}

void schedule_next_task(){
	volatile uint32_t *pICSR = (volatile uint32_t*)0xE000ED04;
	*pICSR |= (1 << 28);
}

void update_global_tick_count(){
	g_tick_count++;
}

void unblock_tasks(){
	//only do this if the current task is user task (not idle task)
	//that is why i =1 and not i = 0
	for(int i = 1; i < MAX_TASKS; i++){

		if(user_tasks[i].current_state != TASK_READY_STATE){
					if(user_tasks[i].block_count == g_tick_count){
					user_tasks[i].current_state = TASK_READY_STATE;
			}
		}
	}
}
__attribute ((naked)) void PendSV_Handler(void){

	//1. Get the current Task's PSP
	__asm volatile("MRS R0, PSP");

	//2. PUSH the context of currently running Task (R4 to R11)
	__asm volatile("STMDB R0!, {R4-R11}");
	//3. Save the current value of PSP (value of PSP after saving R4 to R11)
	__asm volatile("PUSH {LR}");
	__asm volatile("BL save_psp_value");


	//3. Switch PSP to Context of new Task
	__asm volatile("BL update_next_task");
	__asm volatile("BL get_psp_value");

	//4. POP the manually saved context
	__asm volatile("LDMIA R0!, {R4-R11}"); //by defaultl, LDM is LDMIA
	__asm volatile("MSR PSP, R0"); //update PSP to new PSP Value

	__asm volatile("POP {LR}");
	__asm volatile("BX LR");

}
void SysTick_Handler(void){

		update_global_tick_count();
		unblock_tasks();

		volatile uint32_t *pICSR = (volatile uint32_t*)0xE000ED04;
		*pICSR |= (1 << 28); //set PendSV. Once this is done, execution will jump to PendSVHandler as soon as it exits SystickHandler

}

void MemManage_Handler(){

 	// printf("MemManage_Handler hit\n");
	while(1);

}
void BusFault_Handler(){

	printf("BusFault_Handler hit\n");
	while(1);

}
void UsageFault_Handler(){


	printf("UsageFault_Handler hit\n");
	while(1);

}

void HardFault_Handler(){

	printf("HardFault_Handler hit\n");
	while(1);

}
